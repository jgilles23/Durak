<!DOCTYPE html>
<!--HTML and basic JavaScript copied from https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Create_the_Canvas_and_draw_on_it-->
<html>

<head>
    <meta charset="utf-8" />
    <title>Gamedev Canvas Workshop</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        canvas {
            background: #eee;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>

<body>
    <p style="text-align:center">Durak Card Game</p>

    <canvas id="myCanvas" width="480" height="320"></canvas>

    <script>
        //Definitions
        let canvas = document.getElementById("myCanvas");
        canvas.boxes = []; //Storage for unassigned boxes
        let ctx = canvas.getContext("2d");
        let cardHeight = 0.3;
        let cardWidth = cardHeight * 2 / 3;

        //Class for objects that are drawn and have things drawn in them
        class Box {
            constructor(norm_x, norm_y, norm_w, norm_h, align, parent) {
                /*Makes a box object, the super class for all other objects in Durak
                Input parameters are normalized and should be between 0.0 and 1.0 relative to parent
                Stored parametes are absolute in pixles, unless proceeded by norm_
                If all inputs left undefined will setup root box, encompasses entire canvas
                -norm_x - normalized x coordinate
                -norm_y - normalized y coordnate
                -norm_w - normalized width
                -norm_h - normalized height
                -align - "[t,b,c][l,r,c]" requires 2 letters top,bottom,center left,right,center; default: "tl"
                -parent - parent Box object
                */
                if (norm_x === undefined) {
                    this.isRoot = true;
                    //When a root is being set up, special case
                    [this.norm_x, this.norm_y, this.norm_w, this.norm_h] = [0, 0, 1, 1];
                    this.align = 'tl';
                    this.parent = this;
                    if (canvas.width > canvas.height) {
                        this.x = (canvas.width - canvas.height) / 2;
                        this.y = 0;
                        this.w = canvas.height;
                        this.h = canvas.height;
                    } else {
                        this.x = 0;
                        this.y = 0;
                        this.w = canvas.width;
                        this.height = canvas.height;
                    }
                    let a = Math.min(canvas.width, canvas.height);
                    [this.x, this.y, this.w, this.h] = [a / 4, 0, a, a]

                } else {
                    this.isRoot = false;
                    //Parameter setup as normal
                    this.norm_x = norm_x;
                    this.norm_y = norm_y;
                    this.norm_w = norm_w;
                    this.norm_h = norm_h;
                    this.align = align;
                    this.parent = parent;
                    parent.children.push(this);
                    //Calculate absolute positions
                    this.w = parent.w * norm_w;
                    this.h = parent.h * norm_h;
                    if (align === undefined || align.charAt(0) == "t") {
                        this.x = parent.x + parent.w * norm_x;
                    } else if (align.charAt(0) == "b") {
                        this.x = parent.x + parent.w * norm_x - this.w;
                    } else if (align.charAt(0) == "c") {
                        this.x = parent.x + parent.w * norm_x - this.w / 2;
                    } else {
                        throw "Align parameter not valid."
                    }
                    if (align === undefined || align.charAt(1) == "l") {
                        this.y = parent.y + parent.h * norm_y;
                    } else if (align.charAt(1) == "r") {
                        this.y = parent.y + parent.h * norm_y - this.h;
                    } else if (align.charAt(1) == "c") {
                        this.y = parent.y + parent.h * norm_y - this.h / 2;
                    } else {
                        throw "Align parameter not valid."
                    }
                }
                //Continued (shared) parameter setup
                this.children = [];
                this.strokeColor = "red"; //use undefined to not draw
                this.fillColor = undefined //use undefined to not draw
            }
            //get methods for commonly used parameters
            get mid_x() { //center of x position
                return this.x + this.w / 2;
            }
            get mid_y() { //Center of y position
                return this.y + this.h / 2;
            }
            get right() { //Right bound
                return this.x + this.w;
            }
            get bottom() { //bottom bound
                return this.y + this.h;
            }
            //Method to draw a box
            draw() {
                if (this.strokeColor != undefined || this.fillColor != undefined) {
                    ctx.beginPath();
                    ctx.rect(this.x, this.y, this.w, this.h);
                    if (this.fillColor != undefined) {
                        ctx.fillStyle = this.fillColor;
                        ctx.fill()
                    }
                    if (this.strokeColor != undefined) {
                        ctx.strokeStyle = this.strokeColor;
                        ctx.stroke();
                    }
                    ctx.closePath();
                }
                //Recurse through children and draw them
                this.children.forEach(b => b.draw())
            }
            //Method to handle mouse clicks
            mouseUp() {
                this.children.forEach(b => b.mouseUp())
            }
        }

        //Class for rendering text
        class Text extends Box {
            constructor(norm_x, norm_y, norm_w, norm_h, align, parent, text) {
                /*Class for rendering text in a Box class, inherits from Box
                -text - text to render
                */
                super(norm_x, norm_y, norm_w, norm_h, align, parent);
                this.text = text;
                this.textColor = "black";
            }
            draw() {
                super.draw();
                ctx.font = "16px Arial";
                ctx.fillStyle = this.textColor;
                let x, y
                if (this.align.charAt(0) == "t") {
                    ctx.textBaseline = "top";
                    y = this.y;
                } else if (this.align.charAt(0) == "b") {
                    ctx.textBaseline = "bottom";
                    y = this.bottom;
                } else if (this.align.charAt(0) == "c") {
                    ctx.textBaseline = "middle";
                    y = this.mid_y;
                }
                if (this.align.charAt(1) == "l") {
                    ctx.textAlign = "left";
                    x = this.x;
                } else if (this.align.charAt(1) == "r") {
                    ctx.textAlign = "right";
                    x = this.right;
                } else if (this.align.charAt(1) == "c") {
                    ctx.textAlign = "center";
                    x = this.mid_x;
                }
                ctx.fillText(this.text, x, y)
            }
        }

        //Clickable Button Class
        class Button extends Text {
            constructor(norm_x, norm_y, norm_w, norm_h, align, parent, text, onClick) {
                /*Class for making clickable buttons that do something
                Inherits Text class (use "" for empty text box)
                -onClick - a function to run when the box is clicked
                */
                super(norm_x, norm_y, norm_w, norm_h, align, parent, text)
                this.onClick = onClick;
                this.strokeColor = "black" //Color without mouseover
            }
            checkMouse() {
                let [mx, my] = [canvas.mouse_x, canvas.mouse_y];
                return mx >= this.x && mx < this.right && my >= this.y && my < this.bottom;
            }
            draw() {
                if (this.checkMouse()) {
                    if (canvas.mouseDown) {
                        this.strokeColor = "green";
                        this.textColor = "green";
                    } else {
                        this.strokeColor = "blue";
                        this.textColor = "blue";
                    }
                } else {
                    this.strokeColor = "black";
                    this.textColor = "black";
                }
                super.draw()
            }
            mouseUp() {
                if (this.checkMouse()) {
                    this.onClick();
                }
                super.mouseUp();
            }
        }

        let suitLookup = { c: '\u2663', d: '\u2666', h: '\u2665', s: '\u2660' }
        //Card Class
        class Card extends Button {
            constructor(x, y, align, parent, value, suit) {
                /*Card to be used
                -value - the value of the card from 1(ace) to 13(king)
                -suit - [c,d,h,s] meaning clubs,diamonds,hearts,spades
                */
                let onClick = () => { console.log(`Card ${this.value}${this.suitString} Clicked.`) };
                super(x, y, cardWidth, cardHeight, align, parent, "", onClick);
                this.value = value;
                this.suit = suit.charAt[0];
                this.suitString = suitLookup[suit];
                this.faceup = true; //Setup for facedown card
                //Setup the text box on the card
                new Text(0.1, 0.05, 0.3, 0.3, "tl", this, `${this.value}${this.suitString}`)
            }
            draw() {
                if (this.faceup) {
                    super.draw()
                } else {
                    ctx.beginPath();
                    ctx.rect(this.x, this.y, this.w, this.h);
                    ctx.fillStyle = "cyan";
                    ctx.fill();
                    ctx.strokeStyle = "black";
                    ctx.stroke;
                    ctx.closePath();
                }
            }
        }

        //Handlers
        document.addEventListener("mousemove", mouseMoveHandler, false);
        function mouseMoveHandler(e) {
            canvas.mouse_x = e.clientX - canvas.offsetLeft;
            canvas.mouse_y = e.clientY - canvas.offsetTop;
        }
        document.addEventListener("mousedown", mouseDownHandler, false);
        function mouseDownHandler(e) {
            canvas.mouseDown = true;
        }
        document.addEventListener("mouseup", mouseUpHandler, false);
        function mouseUpHandler(e) {
            canvas.mouseDown = false;
            root.mouseUp(); //Handle the mouseup event
        }

        //Assets
        let root = new Box();
        let big = new Box(0.2, 0.2, 0.3, 0.6, "tl", root)
        let dealButton = new Button(0.5, 0.5, 0.2, 0.1, "cc", big, "Button", () => { console.log("Clicked.") });
        let card = new Card(0.7, 0.1, "tl", root, 7, "c")
        console.log(root);

        //Draw function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            root.draw();
            requestAnimationFrame(draw);
        }
        //Run the script
        draw();
    </script>

</body>

</html>